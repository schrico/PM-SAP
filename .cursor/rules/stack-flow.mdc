---
alwaysApply: true
---

# Technology Stack Rules

This project follows a specific technology stack. Always use these technologies and patterns:

## Core Framework
- **Next.js + TypeScript** - Core framework with TypeScript for type safety
- **middleware.ts** - Use for authentication, routing, and security middleware

## Database & Authentication
- **Supabase** - For data, authentication, and storage
- Use Supabase client for all database operations
- Implement proper authentication flows with Supabase Auth

### Database Schema
The project uses the following Supabase tables:

#### 1. users
```sql
create table public.users (
  id uuid not null default gen_random_uuid (),
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone null default now(),
  name text null default 'Sem nome :('::text,
  email text not null,
  role public.user_role not null default 'admin'::user_role,
  "TE_user" text null,
  "C_user" text null,
  short_name text null,
  constraint users_pkey primary key (id),
  constraint users_C - user_key unique ("C_user"),
  constraint users_TE - user_key unique ("TE_user"),
  constraint users_email_key unique (email),
  constraint users_short_name_key unique (short_name),
  constraint users_short_name_check check ((length(short_name) < 8))
) TABLESPACE pg_default;

create trigger set_timestamp BEFORE
update on users for EACH row
execute FUNCTION update_updated_at_column ();

create trigger update_users_updated_at BEFORE
update on users for EACH row
execute FUNCTION update_updated_at_column ();
```

#### 2. projects
```sql
create table public.projects (
  id bigint generated by default as identity not null,
  created_at timestamp with time zone not null default now(),
  name text not null,
  final_deadline timestamp with time zone null,
  words integer null,
  system text not null,
  status public.project_status not null default 'active'::project_status,
  instructions text null default 'Sem descrição fornecida'::text,
  updated_at timestamp with time zone not null default now(),
  paid boolean null default false,
  invoiced boolean null default false,
  lines smallint null,
  language_in text null,
  language_out text null,
  short boolean null,
  initial_deadline timestamp with time zone null,
  interim_deadline timestamp with time zone null,
  constraint projects_pkey primary key (id),
  constraint projects_id_key unique (id)
) TABLESPACE pg_default;

create index IF not exists idx_projects_deadline on public.projects using btree (final_deadline) TABLESPACE pg_default;

create trigger update_projects_updated_at BEFORE
update on projects for EACH row
execute FUNCTION update_updated_at_column ();
```

#### 3. projects_assignment
```sql
create table public.projects_assignment (
  project_id bigint generated by default as identity not null,
  user_id uuid not null,
  created_at timestamp with time zone not null default now(),
  assignment_status public.assignment_status null default 'unclaimed'::assignment_status,
  initial_message text null,
  refusal_message text null,
  done_message text null,
  constraint projects_assignment_pkey primary key (project_id, user_id),
  constraint projects_assignment_project_id_fkey foreign KEY (project_id) references projects (id) on update RESTRICT on delete CASCADE,
  constraint projects_assignment_user_id_fkey foreign KEY (user_id) references users (id) on update RESTRICT on delete CASCADE
) TABLESPACE pg_default;

create index IF not exists idx_projects_assignment_project_id on public.projects_assignment using btree (project_id) TABLESPACE pg_default;

create index IF not exists idx_projects_assignment_user_id on public.projects_assignment using btree (user_id) TABLESPACE pg_default;

create trigger trg_clear_pm_after_delete
after DELETE on projects_assignment for EACH row
execute FUNCTION clear_pm_if_no_assignments ();
```

#### 4. color_settings
```sql
create table public.color_settings (
  id bigserial not null,
  setting_key character varying(100) not null,
  color_value character varying(50) not null,
  category character varying(50) not null,
  system_name character varying(100) null,
  status_key character varying(50) null,
  language_in character varying(10) null,
  language_out character varying(10) null,
  description text null,
  created_at timestamp without time zone null default now(),
  updated_at timestamp without time zone null default now(),
  constraint color_settings_pkey primary key (id),
  constraint color_settings_setting_key_key unique (setting_key),
  constraint color_settings_category_check check (
    (
      (category)::text = any (
        (
          array[
            'system'::character varying,
            'language'::character varying,
            'status'::character varying
          ]
        )::text[]
      )
    )
  )
) TABLESPACE pg_default;

create trigger trg_color_settings_updated_at BEFORE
update on color_settings for EACH row
execute FUNCTION set_updated_at ();
```

### Database Guidelines
- Always use proper TypeScript types that match the database schema
- Use Zod schemas for validating data from Supabase
- Implement proper error handling for database operations
- Use React Query for caching and managing database state
- Follow Supabase best practices for RLS (Row Level Security) when needed

## Styling & UI
- **Tailwind CSS** - For styling and responsive design
- **shadcn/ui** - Modern UI component library
- Use shadcn/ui components instead of custom UI components when possible

## State Management
- **Zustand** - Lightweight global state management
- Use Zustand for client-side state that needs to be shared across components

## Date Handling
- **date-fns** - For all date manipulation and formatting
- Avoid using native Date methods, use date-fns utilities

## Validation
- **Zod** - For schema validation and runtime type checking
- Use Zod schemas for form validation and API data validation

## Forms
- **React Hook Form** - For form handling
- Integrate React Hook Form with Zod for validation
- Use proper form patterns with error handling

## Data Fetching
- **React Query (TanStack Query)** - For server state management
- Use React Query for all API calls, caching, and refetching
- Implement proper loading states and error handling

## Icons
- **lucide-react** - For all icon needs
- Use lucide-react icons consistently throughout the application

## Code Quality
- **ESLint + Prettier** - For code linting and formatting
- Follow consistent code style and formatting rules
- Use proper TypeScript types and avoid `any`

## Environment Configuration
- **Next.js env system** - For environment variables
- Use proper environment variable naming conventions
- Implement secure configuration management

## Implementation Guidelines
- Always use TypeScript with proper typing
- Follow Next.js 16 best practices for routing and API routes and in general use mcp if needed
- Implement proper error boundaries and loading states
- Use React Query for all data fetching operations
- Validate all data with Zod schemas
- Use Tailwind for styling with shadcn/ui components
- Implement proper authentication flows with Supabase
- Follow consistent file structure and naming conventions
